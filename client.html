<!DOCTYPE html>
<html>
<head>
  <title>ATBattler v0.1</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="css/atbattler.css"/>
  <script src="js/vendor/jquery-1.8.2.min.js"></script>
  <script src="js/vendor/underscore-min.js"></script>
  <script src="js/vendor/async.min.js"></script>
  <script src="js/vendor/state-machine.min.js"></script>
  <script src="js/vendor/easeljs-0.5.0.min.js"></script>
  <script src="js/vendor/easeljs/ColorFilter.js"></script>
  <script src="js/vendor/tweenjs-0.3.0.min.js"></script>
  <script src="js/vendor/easeljs/CSSPlugin.js"></script>
  <script src="js/vendor/preloadjs-0.2.0.min.js"></script>
  <script src="js/vendor/jquery.hotkeys-0.8.js"></script>
  <script src="js/domain.js"></script>
  <script src="js/util.js"></script>
  <script src="js/durationevent.js"></script>
  <script src="js/gameevent.js"></script>
  <script src="js/item.js"></script>
  <script src="js/skill.js"></script>
  <script src="js/gameinstance.js"></script>
  <script src="js/gameclient.js"></script>
  <script src="js/view.js"></script>
  <script src="js/canvas.js"></script>

  <!-- EaselJS setup -->
  <script type="text/javascript">
    var FPS = 60;
    var SECOND = 1000;  // a second is 1000ms
    var msPerFrame = SECOND/FPS; // approximate
    var HERO_BASE_X = 150;
    var HERO_BASE_Y = 150;
    var HERO_SPACE_X = 15;
    var HERO_SPACE_Y = 65;
    var HERO_PERSPECTIVE_SCALE = 0.15;

    var manifest = null; // FIXME: don't like this being global...
    var backdrop;
    var runningRate = 2.5;
    var w, h;
    var counter = 0;  // duration of game (temp)
    var effectNumGen; // dem popping numbers

    var heroIdToSprite = [];  // maps heroes to sprites

    function registerHeroSprite(hero, index, numHeroes, dir) {
      var sheet = atb.sheet.getHeroSheet(hero.img[0], hero.img[1]);
      var sprite = new createjs.BitmapAnimation(sheet);
      // add hero to stage 
      if (dir == 'left') {
        sprite.x = w-HERO_BASE_X + HERO_SPACE_X*index + 10*index;
        sprite.gotoAndPlay("idle_l");
      } else {
        sprite.x = HERO_BASE_X - HERO_SPACE_X*index - 10*index;
        sprite.gotoAndPlay("idle_r");
      }
      sprite.origX = sprite.x;
      sprite.y = HERO_BASE_Y + HERO_SPACE_Y*index;
      sprite.origY = sprite.y;
      sprite.scaleX = sprite.scaleY = atb.HERO_BASE_SCALE-((numHeroes-index)*HERO_PERSPECTIVE_SCALE);
      atb.stage.addChild(sprite);
      return sprite;
    }

    function init() {
      createjs.CSSPlugin.install();

      // create a new stage and point it at our canvas:
      var canvas =document.getElementById("main-canvas");
      atb.stage = new createjs.Stage(canvas);
    
      // grab canvas width and height for later calculations:
      w = canvas.width;
      h = canvas.height;

      var bgImage = new Image();
      bgImage.src = manifest[0];

      // Add backdrop to the stage (stretch to fit)
      backdrop =  new createjs.Shape(new createjs.Graphics().beginBitmapFill(bgImage, 'no-repeat').drawRect(0,0,bgImage.width,bgImage.height));
      backdrop.scaleX = Math.ceil(w/bgImage.width);
      backdrop.scaleY = Math.ceil(h/bgImage.height);
      atb.stage.addChild(backdrop);

      // add elapsed time counter to stage
      elapsedLabel = new createjs.Text("0s","bold 14px Arial","#FFF");
      atb.stage.addChild(elapsedLabel);
      elapsedLabel.x = 10;
      elapsedLabel.y = 10;

      // player sprites 
      var playerParty = gameClient.me.party;
      var partyLength = playerParty.heroes.length;
      _.each(playerParty.heroes, function(hero, index) {
          // store sprite for later reference
          heroIdToSprite[hero.id] = registerHeroSprite(hero, index, partyLength, 'right');
        });

      // enemy sprites
      var enemyParty = gameClient.enemy.party;
      partyLength = enemyParty.heroes.length;
      _.each(enemyParty.heroes, function(hero, index, list) {
          // store sprite for later reference
          heroIdToSprite[hero.id] = registerHeroSprite(hero, index, partyLength, 'left');
        });

      // Number popping thing.
      effectNumGen = new atb.EffectNumberGenerator(atb.stage);

      // canvas setup complete, allow game to be started
      atb.stage.update();
      $('#start').show();
    }

    // the view's game loop
    function tick() {
      //fpsLabel.text = Math.round(createjs.Ticker.getMeasuredFPS())+" fps";
      var toUpdate = gameClient.update();
      if (toUpdate && toUpdate.length > 0) {
        // _.each(toUpdate, updateHero);
        for (var i = 0, len = toUpdate.length; i < len; i++) {
          updateHero(toUpdate[i]);
        }
      }
      elapsedLabel.text = counter + "s";
      atb.anim.runCustomUpdates();
      atb.stage.update();
    }
  </script>

  <style>
    #commands-anchor {
      position: absolute;
      top: 0;
      min-height: 300px;
      width:200px;
      left: 375px;
      overflow: hidden;
    }
    .menu-pane {
      background-color: rgba(10, 50, 110, 0.9);
      margin: 0 10px;
      float: left;
      position: relative;
      z-index: 2;
      width: 158px;
    }
    .menu-pane ul {
      list-style-type: none;
      list-style-position: inside;
      margin: 0;
      padding: 0;
    }
    .menu-pane li {
      position: relative;
    }
    /* Selected Menu Item pointer */
    .menu-pane li.selected:before {
      content: url('img/pointer.png');
      left: -18px;
      top: 2px;
      z-index: 1000;
      position: absolute;
    }
    .menu-pane a {
      border-radius: 4px;
      color: #eee;
      display: block;
      padding: 4px 10px;
      text-decoration: none;
      background-color: rgba(38,128,208,0);
      -webkit-transition: background-color 0.2s ease-out 0s;
      -ms-transition: background-color 0.2s ease-out 0s;
      -o-transition: background-color 0.2s ease-out 0s;
      transition: background-color 0.2s ease-out 0s;
    }
    .menu-pane a:hover, .menu-pane li.selected a {
      background-color: rgba(38,128,208,0.8);
    }

    .menu-pane a.disabled {
      color: #888;
    }

    .menu-pane .pane-title {
      margin-bottom: 8px;
    }

    .command-tray {
      position:relative;
      width:1600px;left:0px;
    }

    .command-pane {
      min-height: 120px;
      z-index:3;
    }

    .target-menu {
      display: block;
      position: absolute;
      top: 25px;
      left: 450px;
      z-index:5;
    }

    .item-menu {
      display: block;
      height: 160px;
      left: 230px;
      position: absolute;
      top: 0px;
      width: 630px;
      z-index:4;
    }
    .item-menu .tooltip {
      background-color: rgba(0, 25, 70, 0.9);
      font-weight: normal;
      height: 20px;
      margin: 0 0 10px 0;
      padding: 5px 10px;
    }
    .item-list {
      overflow-y: scroll;
      height: 120px;
    }
    .item-menu li {
      width: 280px;
      float: left;
      margin-left: 20px;
    }
    .item-menu li .qty {
      float: right;
      display: block;
    }

    #party .selected {
      background-color: rgba(10, 50, 110, 0.9);
    }
    #player-pane {
      left: 0px;
      height:160px;
      position: absolute;
      width: 480px;
    }
    #enemy-pane {
      left: 500px;
      height:160px;
      position: absolute;
      width: 440px;
    }

    .hero-list {
      border: none;
      border-collapse:collapse;
    }
    .hero-list td {
      padding: 6px 12px;
    }
    .hero-list td.hp {
      width: 50px;
      text-align: right;
    }
    .hero-list th {
      font-size: 12px;
      font-weight: normal;
    }

    #pause, #resume, #start {
      background-color: #37c;
      border: 1px solid rgb(48, 121, 237);
      border-radius: 2px;
      color: white;
      cursor: pointer;
      display:none;
      float:right;
      font-family: arial;
      font-weight: bold;
      padding: 5px 10px;
    }
    #pause:hover, #resume:hover, #start:hover {
      background-color: #59e;
    }

    #command-next, #command-prev {
      background-color: #37c;
      border: 1px solid rgb(48, 121, 237);
      border-radius: 2px;
      color: white;
      display: none;
      font-family: arial;
      font-weight: bold;
      left: 524px;
      position: absolute;
      width: 30px;
      height: 25px;
      padding-bottom: 2px;
      z-index:3;
    }
    #command-prev {
      left: 394px;
    }

    #skill-name-pane {
      height:20px;
      left:10px; 
      opacity: 0;
      position:absolute; 
      padding: 10px 18px 12px 18px;
      top:10px; 
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="width:960px;">
      <h1 class="logo"><span class="atb"><strong>AT</strong>B</span>attler</h1>
      <span class="fineprint">v0.1</span>
      <button id="pause"/>Pause Game</button>
      <button id="resume"/>Resume Game</button>
      <button id="start"/>Start Game</button>
    </div>
    <div style="position:relative"> 
      <div id="skill-name-pane" class="base-pane"></div>
      <canvas id="main-canvas" height="460" width="960">
      </canvas>
      <div style="position:relative;height:165px;">
        <div id="player-pane" class="base-pane">
          <div id="commands-anchor"></div>
          <button id="command-prev" onClick="commandCarousel.moveRight();">&laquo;</button>
          <button id="command-next" onClick="commandCarousel.moveLeft();">&raquo;</button>
          <table id="party" class="hero-list">
            <thead>
              <th>Name</th>
              <th>HP</th>
              <th>SP</th>
              <th></th>
            </thead>
            <tbody>
            </tbody>
          </table>
        </div>
        <div id="enemy-pane" class="base-pane">
          <table id="enemy" class="hero-list">
            <thead>
              <th>Name</th>
              <th>HP</th>
              <th>SP</th>
              <th></th>
            </thead>
            <tbody>
            </tbody>
          </table>
        </div> 
      </div>
      <br style="clear:both;"/>
      <div id="combatLog">
        <ul>
        </ul>
      </div>
    </div>
    <script type="text/javascript">
      /** View stuff */
      var hpIncrementers = [];
      var spIncrementers = [];
      var heroRows = [];

      /** Templates **/
      // Hero Row (name, hp, gauge, etc)
      var heroRowTemplate = _.template('<tr id="<%= heroDomId %>" class="hero"'
        + 'position="<%= position %>" data-hero-id="<%= hero.id %>"><td>'
        + '<%= hero.name %></td><td class="hp"><%= hero.attributes.hp %></td>'
        + '<td class="sp"><%= hero.attributes.sp %></td><td class="gauge"><div class="gauge-container"><div class="gauge-bar"></div></div></td></tr>'
         );

      /**
       * Hero Command Menu Content
       */
      var heroCommandPaneTemplate = _.template(
        '<div id="com_<%= hero.id %>" data-hero-id="<%= hero.id %>" class="menu-pane">'
        + '<div class="pane-title"><%= hero.name %></div>'
        + '<div id="comlist_<%= hero.id %>" class="command-list"></div>'
        + '</div>');

      // Hero Command list
      var heroCommandTemplate = _.template('<a href="#" <% if (isDisabled) { %>class="disabled"<% } %> data-skill-id="<%= skill.id %>"><%= skill.name %></a>');

      // Target Menu 
      var heroTargetMenuTemplate = _.template('<div id="tar_menu_<%= hero.id %>"  heroId="<%= hero.id %>" class="target-menu menu-pane"><div id="tar_list_<%= hero.id %>" class="target-list"></div></div>');

      // Target Menu list item
      var heroTargetTemplate =  _.template('<a href="#" data-skill-id="<%= skillId %>" data-hero-id="<%= heroId %>" data-target-id="<%= target.id %>"><%= target.name %></a>');

      // Cancel (close nested menu) list item
      var heroCancelTemplate =  _.template('<a href="#" class="cancel" heroId="<%= heroId %>">Cancel</a>');

      // Item Menu
      var heroItemMenuTemplate = _.template('<div id="item_menu_<%= hero.id %>"  heroId="<%= hero.id %>" class="item-menu menu-pane"><div class="tooltip"></div><div id="item_list_<%= hero.id %>" class="item-list"></div></div>');
      // Item Menu list item
      var heroItemTemplate =  _.template('<a href="#" id="it_<%= item[atb.Item.field.id] %>" data-hero-id="<%= heroId %>"><%= item[atb.Item.field.name] %><div class="qty"><%= qty %></div></a>');

      /** END Templates **/

      /** INVENTORY **/
      // TODO: have an inventory, this is hardcoded:
      var inventory = [
          {item: atb.Item[0], qty: 10},
          {item: atb.Item[1], qty: 10},
          {item: atb.Item[2], qty: 10},
          {item: atb.Item[3], qty: 10},
          {item: atb.Item[6], qty: 10}
        ];
      /** END INVENTORY **/

      // setup/teardown when a hero is rez'd
      function rezHero(hero) {
        var player = hero.player;
        var heroRow = heroRows[hero.id];
        heroRow.removeClass('dead');
        var heroSprite = heroIdToSprite[hero.id];
        atb.tweenHeroRez(heroSprite, hero.player != gameClient.me, heroSprite.origX, heroSprite.origY);
      }
      // setup/teardown when a hero is killed
      function killHero(hero) {
        var player = hero.player;
        var heroRow = heroRows[hero.id];
        heroRow.addClass('dead');
        var heroSprite = heroIdToSprite[hero.id];
        atb.tweenHeroDead(heroSprite, hero.player != gameClient.me, heroSprite.origX, heroSprite.origY);
        resetHero(hero);
        forceHeroHpSp(hero);
        // close all menus
        var menuToClose = $('#com_' + hero.id).data('menu');
        if (menuToClose) {
          menuToClose.cascadeClose();
        }
      }
      function updateHero(hero) {
        // don't update dead people!
        if (hero.statuses.dead) {
          return;
        }
        var player = hero.player;
        var heroRow = heroRows[hero.id];
        var heroGauge = heroRow.find('div.gauge-bar');
        // update gauge
        heroGauge.width(hero.turnGauge + '%');
        // update readiness for player heroes
        if (hero.statuses.ready && hero.player == gameClient.me && !heroRow.hasClass('ready')) {
          openCommandMenu(hero);
          heroRow.addClass('ready');
        }
      }

      function showSkillResult(action) {
        var target =  gameClient.heroes[action.target];

        // play the skill animation
        var skill = atb.Skill.get(action.skillId);
        var sprite = heroIdToSprite[target.id];
        switch (skill.id) {
          case atb.Skill.ATTACK:
            atb.anim.run('strike',
              function() { 
                atb.tweenHeroHit(sprite, target.player != gameClient.me, sprite.origX);
                effectNumGen.generate(action.amount, action.isCrit, sprite);
              },
              sprite, 3);
            break;
          case atb.Skill.ITEM:
            var healType = action.effectType == 'heal_sp' ? action.effectType : 'heal';
            var animType = healType == 'heal_sp' ? 'blue' : 'green';
            var item = atb.Item[action.objectId];
            var itemName = item[atb.Item.field.name];
            atb.showSkillName(itemName);
            atb.anim.run('sparklesUp', 
              function() {
                effectNumGen.generate(action.amount, action.isCrit, sprite, healType);
              }, sprite, 5, animType);
            break;
          default:
            var afterSkill = function() {
              atb.tweenHeroHit(sprite, target.player != gameClient.me, sprite.origX);
              effectNumGen.generate(action.amount, action.isCrit, sprite);
            };
            atb.showSkillName(skill.name);
            switch(skill.id) {
              case 4:
              case 8:
                // Mighty Swing and Shockwave
                atb.anim.run('bigStrike', afterSkill, sprite);
                break;
              case 5:
                // Flare 
                atb.anim.run('rainOfFire', afterSkill, sprite, 10, 400);
                break;
              case 6:
                // Arc Impulse
                atb.anim.run('bolt', afterSkill, sprite, 300);
                break;
              case 7:
                // Blast Chill
                atb.anim.run('frostSpike', afterSkill, sprite);
                break;
              default:
                afterSkill();
            }
            break;
        }
      }

      /**
       * Uses Incrementers to set hero's HP/SP to the model's current value.
       */
      function incrementHeroHpSp(hero) {
        hpIncrementers[hero.id].setTarget(hero.attributes.hp);
        spIncrementers[hero.id].setTarget(hero.attributes.sp);
      }
      /**
       * Forces hero's HP/SP to the model's current value, stopping and
       * overriding running Incrementers.
       */
      function forceHeroHpSp(hero) {
        // stop any existing incrementer, then set current value
        var heroHp = heroRows[hero.id].find('.hp');
        var heroSp = heroRows[hero.id].find('.sp');
        hpIncrementers[hero.id].complete();
        spIncrementers[hero.id].complete();
        heroHp.text(hero.attributes.hp);
        heroSp.text(hero.attributes.sp);
      }

      // take action => reset hero & update targets 
      function takeAction(action) {
        var hero = gameClient.heroes[action.by];
        var target =  gameClient.heroes[action.target];

        resetHero(hero);

        // if Skill incurs a cost, reflect that update to the actor's HP/SP.
        var skill = atb.Skill.get(action.skillId);
        var skillCost = skill.cost;
        if (skillCost && skillCost.sp) {
          incrementHeroHpSp(hero);
        }
        incrementHeroHpSp(target);
        showSkillResult(action);
      }

      function resetHero(hero) {
        var heroRow = heroRows[hero.id];
        hero.statuses.ready = false;
        hero.turnGauge = 0.00;
        heroRow.removeClass('ready');
        updateHero(hero);
      }

      function cancelTargetPane(toClose) {
        var menuAnchor = $('#player-pane');
        targetMenu = menuAnchor.find('.target-menu');
        if (targetMenu.length > 0) {
          targetMenu = targetMenu.data('menu');
          targetMenu.close();
        }
      }


      function executeCommandOnTarget(skillId, actionArgs, actorId, targetId) {
        var hero = gameClient.heroes[actorId];
        var target = gameClient.heroes[targetId];
        var skill = atb.Skill.get(skillId);
        if (skill) {
          switch (skillId) {
            case atb.Skill.ATTACK:
              gameClient.queueEvent(GameEvent.type.player_action, {skillId: atb.Skill.ATTACK, by: hero.id, target: target.id});
              break;
            case atb.Skill.ITEM:
              // Item takes the Item ID as an argument
              var itemId = actionArgs;
              gameClient.queueEvent(GameEvent.type.player_action, {skillId: atb.Skill.ITEM, objectId: itemId, by: hero.id, target: target.id});
              break;
            default:
              gameClient.queueEvent(GameEvent.type.player_action, {skillId: skillId, by: hero.id, target: target.id});
              break;
          }
        } else {
          console.log('Action Not Yet Impl for SkillId: ' + skillId);
        }
        var menuToClose = commandCarousel.getPaneInFocus().data('menu'); 
        menuToClose.cascadeClose();
      }

      function processCommand(commandPane, skillId) {
        var heroId = commandPane.data('hero-id');
        var hero = gameClient.heroes[heroId];
        // 'activemenu' is unreliable, so explicitly attach to the command 
        // menu of the current hero
        // FIXME: is there a cleaner way to do this?
        var heroComMenu = commandPane.data('menu'); 
        switch (skillId) {
          case atb.Skill.ATTACK:
            openTargetMenu(hero, skillId, null, heroComMenu);
            break;
          case atb.Skill.ITEM:
            openItemMenu(hero, activeMenu);
            break;
          case atb.Skill.DEFEND:
            gameClient.queueEvent(GameEvent.type.player_action, {skillId: atb.Skill.DEFEND, by: hero.id});
            var menuToClose = commandCarousel.getPaneInFocus().data('menu'); 
            menuToClose.cascadeClose();
            break;
          default:
            if (atb.Skill.isValid(skillId)) {
              openTargetMenu(hero, skillId, null, heroComMenu);
            } else {
              console.log('Command Not Yet Impl for skillId: ' + skillId);
            }
            break;
        }
      }

      // Main command menu - populated with hero's list of commands
      function openCommandMenu(hero) {
        var heroDomId = '#hero_'+ hero.id;
        var commands = hero.commands;
        var comMenu = new atb.Menu(heroCommandPaneTemplate, {hero: hero});

        // populate with menu items
        var comToMenuItems = _.map(commands, function(skillId) {
            var skill = atb.Skill.get(skillId);
            var isDisabled = !skill.meetsPrereqCast(hero);
            var comHolder = heroCommandTemplate({skill: skill, isDisabled: isDisabled})
            return comHolder;
          });
        comMenu.addMenuItems('.command-list');
        comMenu.items.isWrapAround = true;
        comMenu.items.addItems(comToMenuItems);
        comMenu.onKeyInput = comMenuKeyInputHandler.bind(comMenu);
        comMenu.onPreClose = function() { commandCarousel.remove(hero.id); };
        comMenu.container.data('menu', comMenu);

        // FIXME:
        // add to command carousel 
        commandCarousel.add(comMenu, hero.id)
        if (!activeMenu) {
          setActiveMenu(comMenu);
        }
      }

      // "Item" command menu
      function openItemMenu(hero, parentMenu) {
        var menuAnchor = $('#player-pane');
        var itemMenu = new atb.Menu(heroItemMenuTemplate, {hero: hero}, parentMenu);
        menuAnchor.append(itemMenu.container);

        // populate with items in inventory.
        var itemToMenuItems = _.compact(_.map(inventory, function(slot) {
            return heroItemTemplate({heroId: hero.id, item: slot.item, qty: slot.qty});
          }));

        itemToMenuItems.push(heroCancelTemplate({heroId: hero.id}));
        itemMenu.addMenuItems('.item-list');
        itemMenu.items.isWrapAround = false;
        itemMenu.items.itemsPerRow = 2;
        itemMenu.items.onSelect = function(selected) {
          var domId = selected.find('a').prop('id');
          var itemId = domId.substr(domId.lastIndexOf('_')+1);
          var tooltip = itemId ? atb.Item[itemId][atb.Item.field.desc] : '';
          itemMenu.container.find('.tooltip').html(tooltip);
        }
        itemMenu.items.addItems(itemToMenuItems);
        itemMenu.onKeyInput = itemMenuKeyInputHandler.bind(itemMenu);
        itemMenu.onClose = (function() { setActiveMenu(this.parentMenu) }).bind(itemMenu);
        itemMenu.container.data('menu', itemMenu);
        setActiveMenu(itemMenu);
        itemMenu.container.show();
      }

      // Target Selection Menu
      function openTargetMenu(hero, skillId, actionArgs, parentMenu) {
        var targets = null;
        var allowDeadTargets = false;
        switch (skillId) {
          case atb.Skill.ATTACK:
            targets = gameClient.enemy.party.heroes;
            break;
          case atb.Skill.ITEM:
            targets = gameClient.me.party.heroes;
            // allow dead targets if the item removes the 'dead' status
            var itemId = actionArgs;
            var statuses = atb.Item[itemId][atb.Item.field.statuses];
            allowDeadTargets = (statuses && statuses[0] < 0);
            break;
          default:
            if (atb.Skill.isValid(skillId)) {
              targets = gameClient.enemy.party.heroes;
            } else {
              console.log('Command Not Yet Impl for skillId: ' + skillId);
            }
            break;
        }
        if (targets) {
          var menuAnchor = $('#player-pane');
          var tarMenu = new atb.Menu(heroTargetMenuTemplate, {hero: hero}, parentMenu);
          menuAnchor.append(tarMenu.container);

          // populate with target list as menu items
          var tarToMenuItems = _.compact(_.map(targets, function(target) {
              if (target.statuses.dead && !allowDeadTargets) { 
                return null;
              } else {
                return heroTargetTemplate({skillId: skillId, heroId: hero.id, target: target});
              }
            }));
          tarToMenuItems.push(heroCancelTemplate({heroId: hero.id}));
          tarMenu.addMenuItems('.target-list');
          tarMenu.items.isWrapAround = true;
          tarMenu.items.addItems(tarToMenuItems);

          tarMenu.onKeyInput = tarMenuKeyInputHandler.bind(tarMenu);
          tarMenu.onClose = (function() { setActiveMenu(this.parentMenu) }).bind(tarMenu);
          tarMenu.container.data('menu', tarMenu);
          if (actionArgs) {
            tarMenu.container.data('args', actionArgs);
          }
          setActiveMenu(tarMenu);
          tarMenu.container.show();
        }
      }

      // show/hide nav buttons for command pane if necessary
      function showCommandNavButtons() {
        $('#command-next').slideDown(100);
        $('#command-prev').slideDown(100);
      }
      function hideCommandNavButtons() {
        $('#command-next').slideUp(100);
        $('#command-prev').slideUp(100);
      }

      function onAddRemoveCommandPanes(numPanes) {
        if (numPanes > 1) {
          showCommandNavButtons();
        } else {
          hideCommandNavButtons();
        }
      }

      function onCommandCarouselMoveStart(id) {
        if (id) {
          heroRows[id].removeClass('selected');
          hideCommandNavButtons();
        }
      }
      function onCommandCarouselMoveEnd(id) {
        if (id) {
          heroRows[id].addClass('selected');
          setActiveMenu(commandCarousel.getPaneInFocus().data('menu'));
          if (commandCarousel.numPanes > 1) {
            showCommandNavButtons();
          }
        } else {
          setActiveMenu(null);
        }
      }

      /** MOUSE INPUT HANDLING */

      // command list => handler
      $('#player-pane').on('click', '.command-pane .command-list a', function(event) {
          convertListClickToKeyAction($(event.target), '.command-pane', comMenuKeyInputHandler);
          return false;
      });
      // Target list => handler
      $('#player-pane').on('click', '.target-menu a', function(event) {
          convertListClickToKeyAction($(event.target), '.target-menu', tarMenuKeyInputHandler);
          return false;
      });
      // Item menu click => handler 
      $('#player-pane').on('click', '.item-menu a', function(event) {
          convertListClickToKeyAction($(event.target), '.item-menu', itemMenuKeyInputHandler);
          return false;
      });

      function convertListClickToKeyAction(target, menuSelector, handler) {
          var position = target.parents('li').index();
          // move cursor to clicked position
          var menu = target.parents(menuSelector).data('menu');
          menu.items.selectItem(position);
          // funnel through as an action
          (handler.bind(menu))('action');
      }

      // Start Game
      $('#start').on('click', function(event) {
          gameClient.ready();
          $(this).hide();
          });

      // Pause Game
      $('#pause').on('click', function(event) {
          gameClient.requestPause();
          $(this).hide();
          $('#resume').show();
          });

      // Resume Game
      $('#resume').on('click', function(event) {
          gameClient.requestResume();
          $(this).hide();
          $('#pause').show();
          });

      /** END MOUSE INPUT HANDLING */
      
      function emitterCallback() {
        var type = arguments[0];
        var args = arguments[1] ? arguments[1] : null;

        // View handling of events raised by the Client.
        switch(type) {
          case 'clientLogEvent': 
            var msg = args;
            // FIXME: no limit to messages!
            var combatLog = $('#combatLog');
            var combatLogList = combatLog.find('ul');
            combatLogList.append('<li>'+msg+'</li>');
    //        combatLog.scrollTop(combatLogList.height());
            break;
          case 'clientGameOverEvent':
            var msg = args;
            commandCarousel.clear();
            $('tr', '#party').removeClass('selected');
            // FIXME: arbitrary 1s for animations to complete
            _.delay(function() { createjs.Ticker.setPaused(true); }, 1000);
            gameOverLabel = new createjs.Text(msg, "bold 40px Arial","#FFF");
            atb.stage.addChild(gameOverLabel);
            gameOverLabel.x = 50;
            gameOverLabel.y = 100;
            atb.stage.update();
            break;
          case 'clientSetupCompleteEvent':
            // based on heroes, load sprite assets
            var heroAssets = {};
            _.each(gameClient.heroes, function(curHero) {
                var imgData = curHero.img;
                if (imgData) {
                  heroAssets[imgData[0]] = [atb.img.type.hero, imgData[0]];
                }
              });
            heroAssets = _.values(heroAssets);

            // image array to manifest
            var images = [];

            // background
            // TODO: have this determined by the game
            images.push([1, _.random(0,3)]);
            // heroes
            images = images.concat(heroAssets);
            // animations
            images.push([2, 0]);
            images.push([2, 1]);
            manifest = atb.img.toPreloadManifest(images);

            // Use tag loading for now.
            var preload = new createjs.PreloadJS(false);
            preload.onComplete = init;
            preload.loadManifest(manifest);
            break;
          case 'clientGameStartEvent':
            createjs.Ticker.setFPS(FPS);
            createjs.Ticker.useRAF = true;
            createjs.Ticker.addListener(window);
            $('#pause').show();
            break;
          case 'clientGamePauseEvent':
            createjs.Ticker.setPaused(true);
            break;
          case 'clientGameResumeEvent':
            createjs.Ticker.setPaused(false);
            break;
          case 'clientUpdateHeroEvent':
            var hero = args;
            updateHero(hero);
            break;
          case 'clientHeroDeadEvent':
            var hero = args;
            killHero(hero);
            break;
          case 'clientHeroRezEvent':
            var hero = args;
            rezHero(hero);
            break;
          case 'clientHeroActionEvent':
            takeAction(args);
            break;
          case 'clientResetHeroEvent':
//            console.log('resetting hero ' + args.name);
            resetHero(args);
            break;
          case 'clientSyncHeroEvent':
            var hero = args;
            counter += 0.5;
            updateHero(hero);
            break;
        }
      }
      // attach command carousel
      var commandCarousel = new atb.CommandCarousel($('#commands-anchor'));
      commandCarousel.paneWidth = 180;
      commandCarousel.onAdd = onAddRemoveCommandPanes;
      commandCarousel.onRemove = onAddRemoveCommandPanes;
      commandCarousel.onMoveStart = onCommandCarouselMoveStart;
      commandCarousel.onMoveEnd = onCommandCarouselMoveEnd;

      /** KEYBOARD INPUT SUPPORT **/

      // which menu is in focus and should be modified by keystrokes
      var activeMenu = null;
      function setActiveMenu(newActive) {
        activeMenu = newActive;
      }

      // Command menu keyboard input
      function comMenuKeyInputHandler(key) {
        switch(key) {
          case 'left':
            commandCarousel.moveRight();
            break;
          case 'right':
            commandCarousel.moveLeft();
            break;
          case 'up':
            this.items.moveCursor('up');
            break;
          case 'down':
            this.items.moveCursor('down');
            break;
          case 'action':
            // Action key
            var selected = this.items.curSelected.find('a');
            if (!selected.hasClass('disabled')) {
              var commandPane = commandCarousel.getPaneInFocus();
              var skillId = $(selected).data('skill-id');
              processCommand(commandPane, skillId);
            }
            break;
          default:
            // ignore
        }
      }

      function itemMenuKeyInputHandler(key) {
        // FIXME: too-fast keyboard input can have an action processed multiple
        // times by the client... need to figure out how to prevent this.
        switch(key) {
          case 'left':
          case 'right':
          case 'up':
          case 'down':
            this.items.moveCursor(key);
            break;
          case 'action':
            // Action key
            var selected = this.items.curSelected.find('a');
            var heroId = selected.data('hero-id');
            var isCancel = selected.prop('class') == 'cancel';
            var hero = gameClient.heroes[heroId];
            var itemId = selected.prop('id');
            itemId = itemId.substr(itemId.lastIndexOf('_')+1);
            if (isCancel) {
              // backtrack to command menu
              this.cascadeClose();
            } else {
              openTargetMenu(hero, atb.Skill.ITEM, itemId, this);
            }
            break;
          default:
            // ignore
        }
      }

      // Target menu keyboard input
      function tarMenuKeyInputHandler(key) {
        switch(key) {
          case 'left':
          case 'right':
          case 'up':
          case 'down':
            this.items.moveCursor(key);
            break;
          case 'action':
            // Action key
            var selected = this.items.curSelected.find('a');
            var skillId = selected.data('skill-id');
            var actorId = selected.data('hero-id');
            var targetId = selected.data('target-id');
            var actionArgs = this.container.data('args');
            // TODO: fix cancel.
            if (skillId == 'cancel') {
              // backtrack to command menu
              cancelTargetPane();
            } else {
              executeCommandOnTarget(skillId, actionArgs, actorId, targetId);
            }
            break;
          default:
            // ignore
        }
      }

      function keyInputHandler(keyEvent) {
        var key = keyEvent.data.key;
        if (!activeMenu || !key) {
          return;
        }
        activeMenu.onKeyInput(key);
        keyEvent.stopPropagation();
        return false;
      }

      $(document).on('keydown.left', {key:'left'}, keyInputHandler);
      $(document).on('keydown.right', {key:'right'}, keyInputHandler);
      $(document).on('keydown.up', {key:'up'}, keyInputHandler);
      $(document).on('keydown.down', {key:'down'}, keyInputHandler);
      $(document).on('keydown.space', {key:'action'}, keyInputHandler);
      $(document).on('keydown.return', {key:'action'}, keyInputHandler);

      /** END KEYBOARD INPUT SUPPORT */


      // ***** GAME SETUP *****

      // TODO: much of this should be 'server side'.
      var clock = new Clock(msPerFrame);
      var gameInstance = new GameInstance(clock);
      // *YOU
      var player = new Player(1, 'You');
      var party = new Party(1, 4);

      // FIXME: should have a consolidated hero generator/persistence.
      var genHeroes= [];
      genHeroes.push(rollPlayerHero(1, 'Jergens'));
      genHeroes.push(rollPlayerHero(2, 'Milton'));
      genHeroes.push(rollPlayerHero(3, 'Haruka'));
      genHeroes.push(rollPlayerHero(4, 'Leena'));
      // sprites for heroes
      genHeroes[0].img = [1, 3];
      genHeroes[1].img = [1, 0];
      genHeroes[2].img = [0, 4];
      genHeroes[3].img = [1, 4];

      for (var i=0; i<genHeroes.length; i++) {
        party.setHero(genHeroes[i]);
      }
      player.setParty(party);
      player.sendMessage = function(message) {
//        console.log('Player got msg: ' + message);
        gameClient.eventsIn.push(message);
      };

      // *OPPONENT
      var enemy = new Player(2, 'Enemy');
      var enemyParty = new Party(1, 4);
      enemyParty.setHero(rollCpuHero(100, 'Teh Badguy'));
      enemyParty.heroes[0].img = [2, 2];
      enemyParty.setHero(rollCpuHero(200, 'Wagglerstein'));
      enemyParty.heroes[1].img = [2, 0];
      enemyParty.setHero(rollPlayerHero(201, 'Shopgirl 10K'));
      enemyParty.heroes[2].img = [2, 7];
      enemy.setParty(enemyParty);
      enemy.sendMessage = function(message) {
//        console.log('CPU got msg: ' + message);
        cpuGameClient.eventsIn.push(message);
      }

      gameInstance.addPlayers(player, enemy);

      var gameClient = new GameClient(player.id, emitterCallback);
      var cpuGameClient = new CpuGameClient(enemy.id);
      
      // Game instance initiates setup (Player Clients will need to
      // respond)
      gameInstance.setup();

      // TODO: Command list needs to come down from server, separate instances
      // for each Hero
      var commands = [
          atb.Skill.ATTACK,
          null, 
          atb.Skill.ITEM,
          atb.Skill.DEFEND
        ];

      // TODO: this should be somewhere better 
      for (var i = 0; i < gameClient.heroes.length; i++) {
        var curHero = gameClient.heroes[i];
        if (!curHero) { 
          continue;
        }

        // FIXME: hero command list - randomly assign a special skill
        curHero.commands = _.clone(commands);
        curHero.commands[1] = _.random(atb.Skill.SKILLS_START, atb.SkillData.length-1);
        var isPlayer = curHero.player == gameClient.me;
        var heroDomId = 'hero_'+ curHero.id;
        var heroHp = curHero.attributes.hp;
        var heroSp = curHero.attributes.sp;

        var heroPane = isPlayer ? $("#party > tbody") : $("#enemy > tbody");
        heroPane.append(heroRowTemplate({heroDomId: heroDomId, position: i, hero: curHero}));

        heroRows[curHero.id] = $('#' + heroDomId);
        var onUpdate = function(val, isPositive) {
          var percent = val/this.attrMax;
          var rgb = '#fff';
          if (isPositive) {	
            rgb = '#2e6';
          } else {
            if (percent < 0.3) {
              rgb = 'rgb(255,'+ (Math.round(percent/0.2*215)+40) + ',0)';
            } else if (percent < 0.6) {
              rgb = 'rgb(255,255,' + Math.round((percent-0.3)/0.3*255)+')';
            }
          }
          this.holder.text(val);
          this.holder.css('color', rgb);
        };
        hpIncrementers[curHero.id] = new atb.GradualIncrementer(heroHp, heroHp, _.bind(onUpdate, { holder: heroRows[curHero.id].find('.hp'), attrMax: curHero.attributes.maxHp }), 0.5);
        spIncrementers[curHero.id] = new atb.GradualIncrementer(heroSp, heroSp, _.bind(onUpdate, { holder: heroRows[curHero.id].find('.sp'), attrMax: curHero.attributes.maxSp }), 0.5);
      }

    </script>
  </div>
  </body>
</html>
