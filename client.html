<!DOCTYPE html>
<html>
<head>
  <title>ATBattler v0.1</title>
  <meta charset="UTF-8">
  <!--<link rel="stylesheet" href="res/css/bootstrap.css">-->
  <link rel="stylesheet" href="css/atbattler.css"/>
  <!--<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>-->
  <script src="js/vendor/jquery-1.8.2.min.js"></script>
  <script src="js/vendor/underscore-min.js"></script>
  <script src="js/vendor/easeljs-0.5.0.min.js"></script>
  <script src="js/vendor/tweenjs-0.3.0.min.js"></script>
  <script src="js/util.js"></script>
  <script src="js/durationevent.js"></script>
  <script src="js/view.js"></script>

  <!-- EaselJS setup -->
  <script type="text/javascript">
    var FPS = 30;
    var SECOND = 1000;  // a second is 1000ms
    var msPerFrame = 33; // approximate
    var HERO_BASE_X = 150;
    var HERO_BASE_Y = 150;
    var HERO_BASE_SCALE = 3;
    var HERO_SPACE_X = 15;
    var HERO_SPACE_Y = 75;
    var HERO_PERSPECTIVE_SCALE = 0.15;


    var backdrop;
    var stage;
    var runningRate = 2.5;
    var w, h;
    var counter = 0;  // duration of game (temp)
    var effectNumGen; // dem popping numbers

    var bgImage = new Image();
    bgImage.src = 'img/plains.png';
    bgImage.onload = init;

    var heroSprites = [];
    var enemySprites = [];

    var heroIdToSprite = [];  // maps heroes to sprites

    function init() {
      // create a new stage and point it at our canvas:
      var canvas =document.getElementById("mainCanvas");
      stage = new createjs.Stage(canvas);
    
      // grab canvas width and height for later calculations:
      w = canvas.width;
      h = canvas.height;

      // Add backdrop to the stage
      backdrop =  new createjs.Shape(new createjs.Graphics().beginBitmapFill(bgImage, 'no-repeat').drawRect(0,0,bgImage.width,bgImage.height));
      backdrop.scaleX = Math.ceil(w/bgImage.width);
      backdrop.scaleY = Math.ceil(h/bgImage.height);
      stage.addChild(backdrop);

      // add elapsed time counter to stage
      elapsedLabel = new createjs.Text("0s","bold 14px Arial","#FFF");
      stage.addChild(elapsedLabel);
      elapsedLabel.x = 10;
      elapsedLabel.y = 10;

      // TODO: hero sprites should be tied to their domain counterparts
      // properly.  We're just arbitrarily mapping them here.
      var jergensSheet = new createjs.SpriteSheet({
        "animations": {
          "idle": [22],
          "walk": [21,23, "walk", 5]
          },
          "images": ["img/jergens.png"],
          "frames": {
              "height": 32,
              "width":24,
              "regX": 16,
              "regY": 12,
              "count": 96
            }
       });
      var miltonSheet = new createjs.SpriteSheet({
        "animations": {
          "idle": [13],
          "walk": [12,14, "walk", 5]
          },
          "images": ["img/jergens.png"],
          "frames": {
              "height": 32,
              "width":24,
              "regX": 16,
              "regY": 12,
              "count": 96
            }
       });
      var harukaSheet = new createjs.SpriteSheet({
        "animations": {
          "idle": [64],
          "walk": [63,65, "walk", 5]
          },
          "images": ["img/amber.png"],
          "frames": {
              "height": 32,
              "width":24,
              "regX": 16,
              "regY": 12,
              "count": 96
            }
       });
      var leenaSheet = new createjs.SpriteSheet({
        "animations": {
          "idle": [61],
          "walk": [60,62, "walk", 5]
          },
          "images": ["img/jergens.png"],
          "frames": {
              "height": 32,
              "width":24,
              "regX": 16,
              "regY": 12,
              "count": 96
            }
       });
      heroSprites.push(new createjs.BitmapAnimation(jergensSheet));
      heroSprites.push(new createjs.BitmapAnimation(miltonSheet));
      heroSprites.push(new createjs.BitmapAnimation(harukaSheet));
      heroSprites.push(new createjs.BitmapAnimation(leenaSheet));
      for (var i = 0, len = heroSprites.length; i < len; i++) {
        var curSprite = heroSprites[i];
        curSprite.x = HERO_BASE_X - HERO_SPACE_X*i - 10*i;
        curSprite.origX = curSprite.x;
        curSprite.y = HERO_BASE_Y + HERO_SPACE_Y*i;
        curSprite.scaleX = curSprite.scaleY = HERO_BASE_SCALE-((len-i)*HERO_PERSPECTIVE_SCALE);
        curSprite.gotoAndPlay("idle");
        stage.addChild(curSprite);
      }
      // enemy sprites
      var badguySheet = new createjs.SpriteSheet({
        "animations": {
          "idle": [43],
          "walk": [42,44, "walk", 5]
          },
          "images": ["img/chara01.png"],
          "frames": {
              "height": 32,
              "width":24,
              "regX": 16,
              "regY": 12,
              "count": 96
            }
       });
      var wagsSheet = new createjs.SpriteSheet({
        "animations": {
          "idle": [37],
          "walk": [36,38, "walk", 5]
          },
          "images": ["img/chara01.png"],
          "frames": {
              "height": 32,
              "width":24,
              "regX": 16,
              "regY": 12,
              "count": 96
            }
       });
      enemySprites.push(new createjs.BitmapAnimation(badguySheet));
      enemySprites.push(new createjs.BitmapAnimation(wagsSheet));
      for (var i = 0, len = enemySprites.length; i < len; i++) {
        var curSprite = enemySprites[i];
        curSprite.x = w-HERO_BASE_X + HERO_SPACE_X*i + 10*i;
        curSprite.origX = curSprite.x;
        curSprite.y = HERO_BASE_Y + HERO_SPACE_Y*i;
        curSprite.scaleX = curSprite.scaleY = HERO_BASE_SCALE-((len-i)*HERO_PERSPECTIVE_SCALE);
        curSprite.gotoAndPlay("idle");
        stage.addChild(curSprite);
      }

      heroIdToSprite[1] = heroSprites[0];
      heroIdToSprite[2] = heroSprites[1];
      heroIdToSprite[3] = heroSprites[2];
      heroIdToSprite[4] = heroSprites[3];
      heroIdToSprite[100] = enemySprites[0];
      heroIdToSprite[200] = enemySprites[1];

      effectNumGen = new EffectNumberGenerator(stage);
      stage.update();
    }

    // the view's game loop
    function tick() {
      //fpsLabel.text = Math.round(createjs.Ticker.getMeasuredFPS())+" fps";
      var toUpdate = gameClient.update();
      if (toUpdate && toUpdate.length > 0) {
        // _.each(toUpdate, updateHero);
        for (var i = 0, len = toUpdate.length; i < len; i++) {
          updateHero(toUpdate[i]);
        }
      }
      elapsedLabel.text = counter + "s";
      stage.update();
    }
  </script>

  <style>
    #action-pane {
      background-color: #036;
      border: 2px solid white;
      border-radius: 4px;
      box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.5);
      color:#eee;
      display: none;
      min-height: 120px;
      left: 375px;
      padding: 10px;
      position: absolute;
      min-width:120px;
      z-index: 2;
    }
    #action-pane ul {
      list-style-type: none;
      list-style-position: inside;
    /*  margin: 0 0 0 20px;*/
      margin: 0;
      padding: 0;
    }
    #action-pane li {
    }
    #action-pane a {
      color: #eee;
      display: block;
      padding: 4px 10px;
      text-decoration: none;
      background-color: rgba(38,128,208,0);
      -webkit-transition-property: background-color;
      -webkit-transition-duration: 0.2s;
      -webkit-transition-timing-function: ease-out;
      -webkit-transition-delay: 0s;
      -webkit-font-smoothing: antialiased;
      -moz-transition-property: background-color;
      -moz-transition-duration: 0.2s;
      -moz-transition-timing-function: ease-out;
      -moz-transition-delay: 0s;
      -ms-transition-property: background-color;
      -ms-transition-duration: 0.2s;
      -ms-transition-timing-function: ease-out;
      -o-transition-property: background-color;
      -o-transition-duration: 0.2s;
      -o-transition-timing-function: ease-out;
      -o-transition-delay: 0s;
      transition-delay: 0s;
    }
    #action-pane a:hover {
      background-color: rgba(38,128,208,0.8);
    }
    #action-pane button {
      border: none;
      background: none;
      color: #eee;
      font-size: 16px;
      font-weight: bold;
      font-family: Arial, sans-serif;
      text-align: left;
      width: 100%;
    }
    #target-pane {
      display: none;
    }

    .encounter {
      height:160px;
      position: relative;
    }
    .encounter td {
      padding: 4px 10px 4px 0;
    }
    .encounter td.hp {
      width: 50px;
      text-align: right;
    }
    .encounter th {
      font-size: 12px;
      font-weight: normal;
    }
	
  </style>
</head>
<body>
  <div class="container">
	<div style="width:960px;">
      <h1 class="logo"><span class="atb"><strong>AT</strong>B</span>attler</h1>
      <span class="fineprint">v0.1</span>
	  <button id="start" style="float:right;"/>Start Game</button>
	</div>
    <div> 
      <canvas id="mainCanvas" width="960" height="480">
      </canvas>
      <div>
        <div class="menu-pane encounter" style="width:480px; float:left;">
          <div id="action-pane">
            <ul>
              <li><a href="#">Attack</a></li>
              <li><a href="#">Skill</a></li>
              <li><a href="#">Item</a></li>
              <li><a href="#">Defend</a></li>
            </ul>
            <div id="target-pane"></div>
            <p><a href="#" class="cancel">Cancel</a></p>
          </div>
          <table id="party">
            <thead>
              <th>Name</th>
              <th>HP</th>
              <th></th>
              <th></th>
            </thead>
            <tbody>
            </tbody>
          </table>
        </div>
        <div class="menu-pane encounter" style="width:440px; float:left">
          <table id="enemy">
            <thead>
              <th>Name</th>
              <th>HP</th>
              <th></th>
              <th></th>
            </thead>
            <tbody>
            </tbody>
          </table>
        </div> 
        <br style="clear:both;"/>
        <div id="combatLog">
          <ul>
          </ul>
        </div>
      </div>
    </div>
    <script type="text/javascript">

      /** === DOMAIN === **/

      function rollPlayerHero(id, name) {
        var theHp =  _.random(1000, 1300);
        var attributes = {
          speed: _.random(100, 130), 
          attack: _.random(200, 220), 
          hp: theHp,
          maxHp: theHp
          };
        return new Hero(id, name, attributes);
      }
      function rollCpuHero(id, name) {
        var theHp = _.random(1200, 1700);
        var attributes = {
          speed: _.random(80, 100), 
          attack: _.random(50, 90), 
          hp: theHp,
          maxHp: theHp
          };
        return new Hero(id, name, attributes);
      }
      /** Hero **/
      function Hero(id, name, attributes) {
        this.id = id;
        this.name = name;

        // TODO: put somewhere else
        this.attributes = attributes;
        this.statuses = {};        

        // TODO: mechanics should be managed by game state
        this.turnGauge = 0.00;
      }
      /** END Hero **/

      /** Party **/
      function Party(id, maxSize) {
        this.id = id;
        this.maxSize = maxSize;

        this.heroes = [];
      }
      var PARTY = Party.prototype;

      // TODO: if position is OOB or party is full
      PARTY.setHero = function(hero, position) {
        var thePosition = position;
        if (position) {
          this.heroes[position] = hero;
        } else {
          for (var i = 0; i < this.maxSize; i++) {
            if (!this.heroes[i]) {
              this.heroes[i] = hero;
              thePosition = i;
              break;
            }
          }
        }
        return thePosition;
      }
      // TODO: if position is OOB or party is empty
      PARTY.removeHero = function(position) {
        if (position < this.maxSize) {
          this.heroes[position] = null;
        }
        return hero;
      }

      PARTY.getHeroById = function(heroId) {
        for (var i = 0; i < this.heroes.length; i++) {
          if (this.heroes[i] && this.heroes[i].id == heroId) {
            return this.heroes[i];
          }
        }
        return null;
      }

      // TODO: JSONify
      /** END Party **/

      /** Player **/
      function Player(id, name) {
        this.id = id;
        this.name = name;

        this.party = null;
      }

      var PLAYER = Player.prototype;

      PLAYER.setParty = function(party) {
        this.party = party;
      }

      /** END Player **/

      /** Game Event **/
      // simple payload for a typed queue event
      function GameEvent(type, content) {
        this.type = type;
        this.content = content;
      }
      /** END Game Event **/


      /** Game Instance (Server) **/
      function GameInstance(clock) {
        // the players
        this.players = [];
        // convenience map for direct access
        this.heroes = {};

        this.isGameOver = false;

        // Game clock
        this.clock = clock;
        // 'Real Clock' Duration clock
        this.durationClock = new Clock(SECOND*0.5);

        // Event Queues 
        this.eventsIn = new EventQueue(this['processInbound'].bind(this));
        this.eventsOut = new EventQueue(this['processOutbound'].bind(this));

        // duration based events to keep track of
        this.durationEventTracker = [];

        // handlers
        $(this.clock).on('tick', this['onTick'].bind(this));
        $(this.durationClock).on('tick', this['onDurationTick'].bind(this));
      }

      var GI = GameInstance.prototype;

      // adds the specified players to the game
      GI.addPlayers = function(players) {
        for (var i = 0; i < arguments.length; i++) {
          var curPlayer = arguments[i];
          this.players.push(curPlayer);
          for (var j = 0; j < curPlayer.party.heroes.length; j++) {
            var curHero = curPlayer.party.heroes[j];
            this.heroes[curHero.id] = curHero;
          }
        }
      }

      /** Clock and Events */
      GI.start = function() {
        this.clock.start();
        this.durationClock.start();
      }
      GI.stop = function() {
        this.clock.stop();
        this.durationClock.stop();
      }
      GI.onTick = function() {
        this.eventsIn.push(new GameEvent('tick'));
      }
      GI.onDurationTick = function() {
        this.eventsIn.push(new GameEvent('durationTick'));
      }
      GI.queueAction = function(action) {
        this.eventsIn.push(action);
      }

      // Perform upkeep on a real-time tick basis
      GI.doTickUpkeep = function() {
        // TODO: do the rest of the stuff!
        this.update();
      }
      // execute an action
      GI.executeAction = function(action) {
        var results = [];
        // FIXME: this precludes dual-tech/triple-tech etc.
        var actor = this.heroes[action.by];
        var target = this.heroes[action.target];
        // drop actions from non-ready actors
        if (!actor || !actor.statuses.ready) {
          console.log('Server: ' + actor.name + ' is not ready; ignoring action request');
          return;
        }
        // TODO: these should be in handlers or something more organized
        switch(action.type) {
          case 'attack':
          case 'skill':                        
            var dmg = actor.attributes.attack * (_.random(95, 105)/100); //5% variance for now.
            // 5% crit chance for now
            var isCrit = (_.random(0,99)) < 5;
            if (isCrit) {
              dmg *= 1.5;
            }
            dmg = Math.round(dmg);
            var overkill = 0;
            target.attributes.hp -= dmg;
            results.push(new GameEvent('action', {type: action.type, by: actor.id, target: target.id, amount: dmg, isCrit: isCrit}));
            if (target.attributes.hp <= 0) {
              overkill = -(target.attributes.hp);
              target.attributes.hp = 0;
              target.statuses.dead = true;
              results.push(new GameEvent('heroes_dead', [target.id]));
            }
            // reset actor
            actor.statuses.ready = false;
            actor.turnGauge = 0.00;
            break;
          case 'item':
            // FIXME: this is a placeholder for a 'heal'
            // Heals 20% of maxHp
            var amount = Math.round(target.attributes.maxHp * 0.20);
            target.attributes.hp += amount;
            if (target.attributes.hp > target.attributes.maxHp) {
              target.attributes.hp = target.attributes.maxHp;
            }
            results.push(new GameEvent('action', {type: 'item', by: actor.id, target: target.id, amount: amount}));
            // reset actor
            actor.statuses.ready = false;
            actor.turnGauge = 0.00;
            break;
          default:
            console.log('Unknown action type ' + action.type);
            break;
        } // switch

        for (var i = 0; i < results.length; i++) {
          this.eventsOut.push(results[i]);
        }
      }

      // Inbound event processor
      GI.processInbound = function() {
        var theEvent = this.eventsIn.shift();
        if (!theEvent || !theEvent.type) {
          console.log('Server: no event or event type, ignoring.');
          return;
        }

        switch (theEvent.type) {
          case 'tick':
            // update real-tick-based stuff
            this.doTickUpkeep();
            break;
          case 'durationTick':
            // update duration-based stuff.  Filter out completed events.
       //     this.durationEventTracker = this.durationEventTracker.filter(this.updateDurationEvent(theEvent));
            var sync = _.map(this.heroes, function(theHero) {
              return [theHero.id, theHero.turnGauge];
            });
            this.eventsOut.push(new GameEvent('heroes_sync', sync));
            break;
          case 'client_action':
            // execute action
            this.executeAction(theEvent.content);
            break;
          default:
            console.log('Unknown event type: ' + theEvent.type);
            break;
        }
      }

      GI.processOutbound = function() {
        var theEvent = this.eventsOut.shift();

        // FIXME: this is just a simulated broadcast. 
        // GLOBAL
        gameClient.queueEvent(theEvent);
      }

      // Game-clock ticks
      GI.update = function() {
        if (this.isGameOver) {
          return;
        }
        for (var i = 0, len = this.players.length; i < len; i++) {
          var curPlayer = this.players[i];

          // game over condition:
          if (_.all(_.pluck(curPlayer.party.heroes, 'statuses'), function(statuses) { return statuses.dead; })) {
            this.gameOver(_.filter(this.players, function(curPlayer) {
                return(curPlayer.id != this.players[i].id);
              }, this));
            return;
          }

          // player ready condition
          var newlyReady = _.filter(curPlayer.party.heroes, function(curHero) {
            if (curHero && !curHero.statuses.dead && !curHero.statuses.ready) {
              curHero.turnGauge += curHero.attributes.speed / 100.00;
              if (curHero.turnGauge >= 100) {
                curHero.statuses.ready = true;
                curHero.turnGauge = 100.00;
                return true;
              }
            }
            return false;
          });

          // broadcast new ready players to clients
          // TODO
          if(newlyReady.length > 0) {
            this.eventsOut.push(new GameEvent('heroes_ready', _.pluck(newlyReady, 'id')));
          }
        } // for i
      }

      
      GI.gameOver = function(winner) {
        this.stop();
        this.isGameOver = true;
        this.eventsIn.clear();
        this.eventsOut.push(new GameEvent('game_over', winner ? winner[0] : ''));
        $(this.clock).off('tick');
        $(this.durationClock).off('tick');

      }
      /** END Game Instance (server) **/

      /** CPU Player (lololol) **/
      function CpuPlayer(cpuPlayer, game) {
        this.me = cpuPlayer;
        this.game = game;
        //TODO
      }

      /** END CPU Player

      /***********************************************************************/

      /** Game (Client) **/
      function GameClient(myId) {
        this.players = [];
        this.heroes = [];
        this.gameInstance = null;
        this.myId = myId;
        this.me = null;
        this.enemy = null;

        this.eventsIn = new EventQueue(this['processEvent'].bind(this));
      }

      var GC = GameClient.prototype;

      // TODO: this should come 'down' from the server
      GC.setup = function(gameInstance) {
        this.gameInstance = gameInstance;

        // TODO: here we are mimicking 'receiving' player data from server
        for (var i = 0; i < this.gameInstance.players.length; i++) {
          // take the raw JSON ver of the 'Player' and mash its data into an 
          // empty instance of the Domain Player class.  
          var rawPlayer = JSON.parse(JSON.stringify(this.gameInstance.players[i]));
          // this is ugly as sin.
          var playerToAdd = new Player(rawPlayer.id, rawPlayer.name);
          var party = new Party(rawPlayer.party.id, rawPlayer.party.maxSize);
          _.each(rawPlayer.party.heroes, function(rawHero) {
              party.setHero(_.extend(new Hero(), rawHero));
          });
          playerToAdd.setParty(party);
          this.addPlayers(playerToAdd);

          // this is you!
          if (playerToAdd.id == this.myId) {
            this.me = playerToAdd;
          } else {
            // FIXME: works for 1 enemy only 
            this.enemy = playerToAdd;
          }
        }
      }

      GC.start = function() {
        this.gameInstance.start();
        $(this).trigger('clientGameStartEvent');
        this.log('Game start!');
      }

      // TODO: should this even be here?
      // to be called by the view's game loop
      GC.update = function() {
        // client-side 'smooth gauge'.  Use client speed values to 
        // extrapolate gauge, subject to server-sync.
        var toUpdate = _.filter(this.heroes, function(curHero) {
            if (!curHero.statuses.dead && !curHero.statuses.ready) {
              curHero.turnGauge += curHero.attributes.speed / 100.00;
              if (curHero.turnGauge >= 100) {
                curHero.turnGauge = 100.00;
              }
              return true;
            }
            return false;
          });
        return toUpdate;
      }

      GC.stop = function() {
        this.gameInstance.stop();
      }

      GC.queueEvent = function(gameEvent) {
        this.eventsIn.push(gameEvent);
      }

      GC.processEvent = function() {
        var theEvent = this.eventsIn.shift();
        var args = theEvent.content;
        if (!theEvent || !theEvent.type) {
          console.log('Client: no event or event type, ignoring.');
          console.log(theEvent);
          return;
        }
        switch (theEvent.type) {
          case 'heroes_sync':
            // sync player/hero timing. Use as sanity check for gauge.
            // TODO: view shit outta here?
            // TODO: need to do the smooth gauge, but use the sync as override
            var heroesSync = args;
            for (var i = 0; i < heroesSync.length; i++) {
              var theHero = this.heroes[heroesSync[i][0]];
              theHero.turnGauge = heroesSync[i][1];
              $(this).trigger('clientUpdateHeroEvent', theHero);
            }
            $(this).trigger('clientSyncHeroEvent', theHero);
            break;
          case 'heroes_ready':
            var readyHeroes = args;
            for (var i = 0; i < readyHeroes.length; i++) {
              var theHero = this.heroes[readyHeroes[i]];
              theHero.statuses.ready = true;
              theHero.turnGauge = 100.00;
              $(this).trigger('clientUpdateHeroEvent', theHero);
            }
            break;
          case 'heroes_dead':
            var deadHeroes = args;
            for (var i = 0; i < deadHeroes.length; i++) {
              var theHero = this.heroes[deadHeroes[i]];
              this.log(theHero.name + ' was slain!');
              theHero.statuses.dead = true;
              theHero.turnGauge = 0.00;
              theHero.attributes.hp = 0;
              $(this).trigger('clientUpdateHeroEvent', theHero);
            }
            break;
          case 'action':
            // execute action
//            console.log('SERVER sent action: ' + JSON.stringify(theEvent.content));
 
            var source = this.heroes[args.by];
            var target = this.heroes[args.target];
            var amount = args.amount;
            var isCrit = args.isCrit ? args.isCrit : false;
            switch(args.type) {
              case 'attack':
                var msg = source.name + ' attacks ' + target.name + ' for ' + args.amount + ' damage.';
                if (isCrit) {
                  msg += ' (Critical Hit)';
                }
                this.log(msg);
                target.attributes.hp -= args.amount;
                if (target.attributes.hp < 0) {
                  target.attributes.hp = 0;
                }				
                break;
              case 'skill':
                var msg = source.name + ' uses skill on ' + target.name + ' for ' + args.amount + ' damage.';
                if (isCrit) {
                  msg += ' (Critical Hit)';
                }
                this.log(msg);
                target.attributes.hp -= args.amount;
                if (target.attributes.hp < 0) {
                  target.attributes.hp = 0;
                }
                break;
              case 'item':
                this.log(source.name + ' uses item on ' + target.name + ' for ' + args.amount + ' healing.');
                target.attributes.hp += args.amount;
                if (target.attributes.hp > target.attributes.maxHp) {
                  target.attributes.hp = target.attributes.maxHp;
                }
                break;
              default:
                console.log('Client received unknown action.type: ' + action.type);
                break;
            }
            $(this).trigger('clientHeroActionEvent', [source, target, args.type, amount, isCrit]);
            break;
          case 'client_action':
            // send action to server
            this.sendToServer(theEvent);
            break;
          case 'game_over':
            this.gameOver(args);
            break;
          default:
            console.log('Unknown event type: ' + theEvent.type);
            break;
        }
      }

      // adds the specified players to the game
      GC.addPlayers = function(players) {
        for (var i = 0; i < arguments.length; i++) {
          var curPlayer = arguments[i];
          this.players.push(curPlayer);
          for (var j = 0; j < curPlayer.party.heroes.length; j++) {
            var curHero = curPlayer.party.heroes[j];
            // augmenting hero with back-link to player
            curHero.player = curPlayer;
            this.heroes[curHero.id] = curHero;
          }
        }
      }

      // sends an action to the server.  
      // FIXME: it writes directly to server's inbound event queue
      GC.sendToServer = function(theEvent) {
        gameInstance.queueAction(theEvent);
      }

      GC.gameOver = function(winner) {
        var winner = _.find(this.players, function(thePlayer) { return thePlayer.id == winner.id; });

        this.stop();
        this.isGameOver = true;
        this.eventsIn.clear();
        $(this.eventsIn).off('queued');

        var msg = null;
        if (winner) {
          if (winner == this.me) {
            msg = 'You have won the battle!';
          } else {
            msg = 'Player ' + winner.name + ' has won the battle!';
          }
        } else {
          msg = 'Game Over!';
        }
        this.log(msg);
        $(this).trigger('clientGameOverEvent', msg);
      }

      // a simple message log.  Allows listener to pickup and handle logging
      GC.log = function(msg) {
        $(this).trigger('clientLogEvent', msg)
      }
      /** END Game (Client) **/


      /** CPU Game Client **/
      function CpuGameClient(myId) {
      }
      CpuGameClient.prototype = new GameClient();
      CpuGameClient.prototype.constructor = CpuGameClient;

      var CPUGC = CpuGameClient.prototype;

      /** END CPU Game Client */


      /***********************************************************************/

      /** View stuff */
      var hpIncrementers = [];
      var heroRows = [];

      function updateHero(hero) {
        var player = hero.player;
        var isYou = player.id == gameClient.myId;
        var heroRow = heroRows[hero.id];
        var heroGauge = heroRow.find('div.gauge-bar');
        // don't update dead people!
        if (hero.statuses.dead) {
          if (!heroRow.hasClass('dead')) {
            heroRow.addClass('dead');
            updateHeroHp(hero, null, 0);
          }
          return;
        }
        // update gauge
        heroGauge.width(hero.turnGauge + '%');
        // update readiness
        if (hero.statuses.ready && heroRow.children('td.action').is(':empty')) {
          heroRow.children('.action').html('<button class="takeAction" heroId="' + hero.id + '">Action</button>');
          heroRow.addClass('ready');

          // TODO: this belongs somewhere else
          // enemy attacks immediately!
          if (!isYou) {
            var opponent = null;
            // find a target opponent (obviously, this is you!)
            for (var i = 0; i < gameInstance.players.length; i++) {
              if (gameInstance.players[i].id != player.id) {
                opponent = gameInstance.players[i];
                break;
              }
            }
            var target = opponent.party.heroes[_.random(0, opponent.party.heroes.length-1)];
            if (target.statuses.dead) {
              target = _.find(opponent.party.heroes, function(theHero) { return !theHero.statuses.dead });
            }
            gameClient.queueEvent(new GameEvent('client_action', {type: 'attack', by: hero.id, target: target.id}));
          }
        }
      }

      function updateHeroHp(hero, type, amount, isCrit) {
        // update hp
        if (type) {
          // let incrementer take care of update
          hpIncrementers[hero.id].setTarget(hero.attributes.hp);
          switch (type) {
            case 'attack':
            case 'skill':
              tweenHeroHit(heroIdToSprite[hero.id], hero.player != gameClient.me, heroIdToSprite[hero.id].origX);
              effectNumGen.generate(amount, isCrit, heroIdToSprite[hero.id]);
              break;
            case 'item':
              effectNumGen.generate(amount, isCrit, heroIdToSprite[hero.id], 'heal');
              break;
            default:
              console.log('unknown type, using default increment');
              effectNumGen.generate(amount, isCrit, heroIdToSprite[hero.id]);
              break;
          }
        } else {
          // stop any existing incrementer, then set your value
          var heroHp = heroRows[hero.id].find('.hp');
          hpIncrementers[hero.id].complete();
          heroHp.text(hero.attributes.hp);
        }
      }

      // take action => reset gauge & action buttons
      function takeAction(hero, target, type, amount, isCrit) {
        var heroRow = heroRows[hero.id];
        heroRow.find('.action').html('');
        hero.statuses.ready = false;
        hero.turnGauge = 0.00;
        heroRow.removeClass('ready');
        updateHero(hero);
        updateHeroHp(target, type, amount, isCrit);
      }

      // action button => show action pane
      $(document).on('click', '.hero .takeAction', function(event) {
          var heroId = $(this).attr('heroId');
          $('#action-pane').show().attr('heroId', heroId);
          $('#action-pane').children('ul').show();
          $('#action-pane').children('#target-pane').hide();
        });

      function closeActionPane() {
        $('#action-pane').hide();
      }

      // target list => take action
      $(document).on('click', '#target-pane a', function(event) {
          var actionType = $(this).attr('class');
          var hero = gameClient.heroes[$(this).attr('heroId')];
          var target = gameClient.heroes[$(this).attr('targetId')];
          switch (actionType) {
            case 'attack':
              gameClient.queueEvent(new GameEvent('client_action', {type: 'attack', by: hero.id, target: target.id}));
              break;
            case 'skill':
              gameClient.queueEvent(new GameEvent('client_action', {type: 'skill', by: hero.id, target: target.id}));
              break;
            case 'item':
              gameClient.queueEvent(new GameEvent('client_action', {type: 'item', by: hero.id, target: target.id}));
              break;
            default:
              console.log('Action Not Yet Impl: ' + actionType);
              break;
          }
          closeActionPane();
          return false;
        });

      $(document).on('click', '#start', function(event) {
          gameClient.start();
          $(this).hide();
          });

      // action pane option => target list (or execute command)
      $(document).on('click', '#action-pane a', function(event) {
          var actionPane = $('#action-pane');
          var heroId = actionPane.attr('heroId');
          
          var targets = null;
          var actionType = $(this).text().toLowerCase();
          switch (actionType) {
            case 'attack':
              targets = gameClient.enemy.party.heroes;
              break;
            case 'skill':
              targets = gameClient.enemy.party.heroes;
              break;
            case 'item':
              targets = gameClient.me.party.heroes;
              break;
            case 'cancel':
              closeActionPane();
              return false;
            default:
              console.log('Action Not Yet Impl: ' + $(this).text());
              break;
          }

          if (targets) {
            actionPane.find('ul').hide();
            var targetList = '<span>';
            for (var i = 0; i < targets.length; i++) {
              var curHero = targets[i];
              if (!curHero.statuses.dead) {
                targetList += '<a href="#" class="' + actionType + '" heroId="'+ heroId +'" targetId="' + curHero.id + '">' + curHero.name + ' </a>';
              }
            }
            targetList += '</span>';
            $('#target-pane').html(targetList).show();
          }
          return false;
          });

      /** END View stuff */
      

      // TODO: much of this should be 'server side'.
      var clock = new Clock(msPerFrame);
      var gameInstance = new GameInstance(clock);
      // *YOU
      var player = new Player(1, 'You');
      var party = new Party(1, 4);
      party.setHero(rollPlayerHero(1, 'Jergens'));
      party.setHero(rollPlayerHero(2, 'Milton'));
      party.setHero(rollPlayerHero(3, 'Haruka'));
      party.setHero(rollPlayerHero(4, 'Leena'));
      player.setParty(party);

      // *OPPONENT
      var enemy = new Player(2, 'Enemy');
      var enemyParty = new Party(1, 4);
      enemyParty.setHero(rollCpuHero(100, 'Teh Badguy'));
      enemyParty.setHero(rollCpuHero(200, 'Wagglerstein'));
      enemy.setParty(enemyParty);

      gameInstance.addPlayers(player, enemy);

      var gameClient = new GameClient(player.id);
      gameClient.setup(gameInstance);

      // TODO: this should be somewhere better 
      for (var i = 0; i < gameClient.heroes.length; i++) {
        var curHero = gameClient.heroes[i];
        if (!curHero) { 
          continue;
        }
        var isYou = curHero.player.id == gameClient.myId;
        var heroDomId = 'hero_'+ curHero.id;
        var heroHp = curHero.attributes.hp;

        var heroPane = $("#party > tbody");
        if (!isYou) {
          heroPane = $("#enemy > tbody");
        }
        heroPane.append('<tr id="'+ heroDomId +'" class="hero" position="'+ i +'" heroId="' + curHero.id +'"><td>' + curHero.name + '</td><td class="hp">' + heroHp 
          + '</td><td class="gauge"><div class="gauge-container"><div class="gauge-bar"></div></div></td><td class="action"></td></tr>');

        heroRows[curHero.id] = $('#' + heroDomId);
        var onUpdate = function(val, isPositive) {           
          var percent = val/this.hero.attributes.maxHp;
          var rgb = '#fff';
          if (isPositive) {	
            rgb = '#2e6';
          } else {
            if (percent < 0.3) {
              rgb = 'rgb(255,'+ (Math.round(percent/0.2*215)+40) + ',0)';
            } else if (percent < 0.6) {
              rgb = 'rgb(255,255,' + Math.round((percent-0.3)/0.3*255)+')';
            }
          }
          this.holder.text(val);
          this.holder.css('color', rgb);
        };
        onUpdate = _.bind(onUpdate, { holder: heroRows[curHero.id].find('.hp'), hero: curHero });
        hpIncrementers[curHero.id] = new GradualIncrementer(heroHp, heroHp, onUpdate, 0.5);
      }

      // View handling of events raised by the Client.
      $(gameClient).on('clientLogEvent', function(event, msg) {
          //console.log(msg);
          // FIXME: no limit to messages!
          var combatLog = $('#combatLog');
          var combatLogList = combatLog.find('ul');
          combatLogList.append('<li>'+msg+'</li>');
//          combatLog.scrollTop(combatLogList.height());
        });
      $(gameClient).on('clientGameOverEvent', function(event, msg) {
          createjs.Ticker.setPaused(true);
          gameOverLabel = new createjs.Text(msg, "bold 40px Arial","#FFF");
          stage.addChild(gameOverLabel);
          gameOverLabel.x = 50;
          gameOverLabel.y = 100;
          stage.update();
        });
      $(gameClient).on('clientGameStartEvent', function(event, msg) {
          createjs.Ticker.setFPS(FPS);
          createjs.Ticker.useRAF = true;
          createjs.Ticker.addListener(window);
        });
      $(gameClient).on('clientUpdateHeroEvent', function(event, hero) {
          updateHero(hero);
        });
      $(gameClient).on('clientHeroActionEvent', function(event, source, target, type, amount, isCrit) {	
          takeAction(source, target, type, amount, isCrit);
        });
      $(gameClient).on('clientSyncHeroEvent', function(event, hero) {
          counter += 0.5;
          updateHero(hero);
      });

    </script>
  </div>
  </body>
</html>
