<!DOCTYPE html>
<html>
<head>
  <title>ATBattler v0.1</title>
  <meta charset="UTF-8">
  <!--<link rel="stylesheet" href="res/css/bootstrap.css">-->
  <!--<script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>-->
  <script src="js/jquery-1.8.2.min.js"></script>
  <script src="js/underscore-min.js"></script>
  <script src="js/util.js"></script>
  <script src="js/durationevent.js"></script>
  <style>
    span.connect{ color: #049cdb; font-weight:bold; }
    span.disconnect{ color: #9d261d; font-weight:bold; }
    span.whisper{ color: #7a43b6; font-weight:bold; }
    span.emote { color: teal; font-style:italic; }
    span.system { color: gray; font-style:italic; }

    body {
      font-family: arial, sans-serif;
    }

    #chatMembers {
      box-shadow: 0px 1px 4px rgba(0, 0, 0, 0.067);
    }
    .me { background-color: #ddddff; }

    #chatContainer.disabled { background-color: #dddddd; }
    #chatContainer {
      box-shadow: 0px 1px 4px rgba(0, 0, 0, 0.067);
      height:400px;
      overflow-y: scroll;
      overflow-x: hidden;
    }
    #chatMessageInput {
      width: 780px;
    }

    #chatLog {
      width:100%;
    }
    #chatLog td {
      border: none;
    }

    #chatLog td.timestamp {
      width: 100px;
      overflow: hidden;
    }


    .gauge {
      width: 200px;
    }

    .gauge div {
      background-color: gray;
      height: 20px;
      border: 1px solid black;
    }

    .gauge div.ready {
      background-color: #ff9966;
    }

    .dead .gauge div {
      background-color: white;
    }

    #enemy button {
      display: none;
    }

    a.chat-link {
      color: inherit;
    }
    a.chat-link:before {
      content: '[';
    }
    a.chat-link:after {
      content: ']';
    }

    canvas { border: 1px solid black; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ATBattler v0.1</h1>
    <div>
      
      <canvas id="mainCanvas" width="800" height="480">
      </canvas>
      <div>
      <div style="width:400px; border:1px solid gray; float:left">
        <table id="party">
          <thead>
            <th>Name</th>
            <th>HP</th>
            <th>Gauge</th>
            <th></th>
          </thead>
          <tbody>
          </tbody>
        </table>
      </div>
      <div style="width:400px; border:1px solid gray; float:left">
        <table id="enemy">
          <thead>
            <th>Name</th>
            <th>HP</th>
            <th>Gauge</th>
            <th></th>
          </thead>
          <tbody>
          </tbody>
        </table>
      </div> 
      <br style="clear:both;"/>
      <p id="postCounter">POST</p>
      <br style="clear:both;"/>
      <label for="chatMessageInput">Chat Message</label>
      <input id="chatMessageInput" name="chatMessageInput" type="textarea" size="50" />
      <p>Press enter to submit your message</p>
      </div>
    </div>
    <script>  
      var canvas = document.getElementById('mainCanvas').getContext('2d');
      var CANVAS_WIDTH=800;
      var CANVAS_HEIGHT=480;

      var FPS = 30;
      var SECOND = 1000;

      var YOU = null;
      var ENEMY = null;

      var postGameOverCounter =0;


      /** === DOMAIN === **/

      function rollPlayerHero(id, name) {
        var attributes = {
          speed: _.random(100, 130), 
          attack: _.random(200, 220), 
          hp: _.random(1000, 1300) 
          };
        return new Hero(id, name, attributes);
      }
      function rollCpuHero(id, name) {
        var attributes = {
          speed: _.random(80, 100), 
          attack: _.random(50, 90), 
          hp: _.random(1200, 1700) 
          };
        return new Hero(id, name, attributes);
      }
      /** Hero **/
      function Hero(id, name, attributes) {
        this.id = id;
        this.name = name;

        // TODO: put somewhere else
        this.attributes = attributes;
        this.statuses = {};        

        // TODO: mechanics should be managed by game state
        this.turnGauge = 0.00;
      }
      /** END Hero **/

      /** Party **/
      function Party(id, maxSize) {
        this.id = id;
        this.maxSize = maxSize;

        this.heroes = [];
      }
      var PARTY = Party.prototype;

      // TODO: if position is OOB or party is full
      PARTY.setHero = function(hero, position) {
        var thePosition = position;
        if (position) {
          this.heroes[position] = hero;
        } else {
          for (var i = 0; i < this.maxSize; i++) {
            if (!this.heroes[i]) {
              this.heroes[i] = hero;
              thePosition = i;
              break;
            }
          }
        }
        return thePosition;
      }
      // TODO: if position is OOB or party is empty
      PARTY.removeHero = function(position) {
        if (position < this.maxSize) {
          this.heroes[position] = null;
        }
        return hero;
      }

      PARTY.getHeroById = function(heroId) {
        for (var i = 0; i < this.heroes.length; i++) {
          if (this.heroes[i] && this.heroes[i].id == heroId) {
            return this.heroes[i];
          }
        }
        return null;
      }

      // TODO: JSONify
      /** END Party **/

      /** Player **/
      function Player(id, name) {
        this.id = id;
        this.name = name;

        this.party = null;
      }

      var PLAYER = Player.prototype;

      PLAYER.setParty = function(party) {
        this.party = party;
      }

      /** END Player **/

      /** Game Event **/
      // simple payload for a typed queue event
      function GameEvent(type, content) {
        this.type = type;
        this.content = content;
      }
      /** END Game Event **/


      /** Game Instance (Server) **/
      function GameInstance(clock) {
        // the players
        this.players = [];
        // convenience map for direct access
        this.heroes = {};

        this.isGameOver = false;

        // Game clock
        this.clock = clock;
        // 'Real Clock' Duration clock
        this.durationClock = new Clock(SECOND*0.5);

        // Event Queues 
        this.eventsIn = new EventQueue();
        this.eventsOut = new EventQueue();

        // duration based events to keep track of
        this.durationEventTracker = [];

        // handlers
        $(this.eventsIn).on('queued', this['processInbound'].bind(this));
        $(this.eventsOut).on('queued', this['processOutbound'].bind(this));
        $(this.clock).on('tick', this['onTick'].bind(this));
        $(this.durationClock).on('tick', this['onDurationTick'].bind(this));
      }

      var GI = GameInstance.prototype;

      // adds the specified players to the game
      GI.addPlayers = function(players) {
        for (var i = 0; i < arguments.length; i++) {
          var curPlayer = arguments[i];
          this.players.push(curPlayer);
          for (var j = 0; j < curPlayer.party.heroes.length; j++) {
            var curHero = curPlayer.party.heroes[j];
            this.heroes[curHero.id] = curHero;
          }
        }
      }

      /** Clock and Events */
      GI.start = function() {
        this.clock.start();
        this.durationClock.start();
      }
      GI.stop = function() {
        this.clock.stop();
        this.durationClock.stop();
      }
      GI.onTick = function() {
        this.eventsIn.push(new GameEvent('tick'));
      }
      GI.onDurationTick = function() {
        this.eventsIn.push(new GameEvent('durationTick'));
      }
      GI.queueAction = function(action) {
        this.eventsIn.push(new GameEvent('action', action));
      }

      // Perform upkeep on a real-time tick basis
      GI.doTickUpkeep = function() {
        // TODO: do the rest of the stuff!
        this.update();
      }
      // execute an action
      GI.executeAction = function(action) {
//        console.log(action.by + ' uses ' + action.type + ' on ' + action.target);
        // TODO: these should be in handlers or something more organized
        switch(action.type) {
          case 'attack':
            var attacker = this.heroes[action.by];
            var target = this.heroes[action.target];
            var dmg = attacker.attributes.attack;
//            console.log(attacker.name + ' attacks ' + target.name + ' for ' + dmg + ' damage');
            target.attributes.hp -= dmg;
            if (target.attributes.hp <= 0) {
              target.attributes.hp = 0;
              target.statuses.dead = true;
            }
            break;
          default:
            console.log('Unknown action type ' + action.type);
            break;
        } // switch
      }

      // Inbound event processor
      GI.processInbound = function() {
        var theEvent = this.eventsIn.shift();
        if (!theEvent || !theEvent.type) {
          console.log('no event or event type, ignoring.');
          return;
        }

        switch (theEvent.type) {
          case 'tick':
            // update real-tick-based stuff
            this.doTickUpkeep();
            break;
          case 'durationTick':
            // update duration-based stuff.  Filter out completed events.
       //     this.durationEventTracker = this.durationEventTracker.filter(this.updateDurationEvent(theEvent));
            var sync = _.map(this.heroes, function(theHero) {
              return [theHero.id, theHero.turnGauge];
            });
            this.eventsOut.push(new GameEvent('heroes_sync', sync));
            break;
          case 'action':
            // execute action
            this.executeAction(theEvent.content);
            break;
          default:
            console.log('Unknown event type: ' + theEvent.type);
            break;
        }
      }

      GI.processOutbound = function() {
        var theEvent = this.eventsOut.shift();

        // FIXME: this is just a simulated broadcast. 
        // GLOBAL
        gameClient.queueEvent(theEvent);
      }

      // Game-clock ticks
      GI.update = function() {
        if (this.isGameOver) {
          postGameOverCounter++;
          $('#postCounter').text(postGameOverCounter);
          return;
        }
        for (var i = 0; i < this.players.length; i++) {
          var curPlayer = this.players[i];

          // game over condition:
          if (_.all(_.pluck(curPlayer.party.heroes, 'statuses'), function(statuses) { return statuses.dead; })) {
            this.gameOver();
            return;
          }

          // player ready condition
          var newlyReady = _.filter(curPlayer.party.heroes, function(curHero) {
            if (curHero && !curHero.statuses.dead && !curHero.statuses.ready) {
              curHero.turnGauge += curHero.attributes.speed / 100.00;
              if (curHero.turnGauge >= 100) {
                curHero.statuses.ready = true;
                curHero.turnGauge = 100.00;
                return true;
              }
            }
            return false;
          });

          // broadcast new ready players to clients
          // TODO
          if(newlyReady.length > 0) {
            this.eventsOut.push(new GameEvent('heroes_ready', _.pluck(newlyReady, 'id')));
//            console.dir(newlyReady);
          }
        } // for i
      }

      
      GI.gameOver = function(winner) {
        this.stop();
        this.isGameOver = true;
        this.eventsIn.clear();
        $(this.eventsIn).off('queued');
        $(this.eventsOff).off('queued');
        $(this.clock).off('tick');
        $(this.durationClock).off('tick');
        alert('game over');
//        alert(winner.name + ' has won!');
      }
      /** END Game Instance (server) **/

      /** CPU Player (lololol) **/
      function CpuPlayer(cpuPlayer, game) {
        this.me = cpuPlayer;
        this.game = game;
        //TODO
      }

      /** END CPU Player

      /** Game (Client) **/
      function GameClient(myId) {
        this.players = [];
        this.heroes = [];
        this.gameInstance = null;
        this.myId = myId;
        this.me = null;

        this.eventsIn = new EventQueue();

        this.gameLoop = null;
        
        $(this.eventsIn).on('queued', this['processEvent'].bind(this));
      }

      var GC = GameClient.prototype;

      // TODO: this should come 'down' from the server
      GC.setup = function(gameInstance) {
        this.gameInstance = gameInstance;

        // TODO: here we are mimicking 'receiving' player data from server
        for (var i = 0; i < this.gameInstance.players.length; i++) {
          // take the raw JSON ver of the 'Player' and mash its data into an 
          // empty instance of the Domain Player class.  
          var rawPlayer = JSON.parse(JSON.stringify(this.gameInstance.players[i]));
          // this is ugly as sin.
          var playerToAdd = new Player(rawPlayer.id, rawPlayer.name);
          var party = new Party(rawPlayer.party.id, rawPlayer.party.maxSize);
          _.each(rawPlayer.party.heroes, function(rawHero) {
              party.setHero(_.extend(new Hero(), rawHero));
          });
          playerToAdd.setParty(party);
          this.addPlayers(playerToAdd);

          // this is you!
          if (playerToAdd.id == this.myId) {
            this.me = playerToAdd;
          }
        }
      }

      GC.start = function() {
        this.gameInstance.start();
        this.gameLoop = setInterval(function() {
            // TODO: factor this out?

            // client-side 'smooth gauge'.  Use client speed values to 
            // extrapolate gauge, subject to server-sync.
            var toUpdate = _.filter(this.heroes, function(curHero) {
                if (!curHero.statuses.dead && !curHero.statuses.ready) {
                  curHero.turnGauge += curHero.attributes.speed / 100.00;
                  if (curHero.turnGauge >= 100) {
                    curHero.turnGauge = 100.00;
                  }
                  return true;
                }
                return false;
              });
            if (toUpdate && toUpdate.length > 0) {
              _.each(toUpdate, updateHero);
            }
            update();
            draw();

            }.bind(this), 1000/FPS);
      }

      GC.stop = function() {
        this.gameInstance.stop();
        stopInterval(this.gameLoop);
      }

      GC.queueEvent = function(gameEvent) {
        this.eventsIn.push(gameEvent);
      }

      GC.processEvent = function() {
        var theEvent = this.eventsIn.shift();
        var args = theEvent.content;
        if (!theEvent || !theEvent.type) {
          console.log('no event or event type, ignoring.');
          return;
        }
        switch (theEvent.type) {
          case 'heroes_sync':
            // sync player/hero timing. Use as sanity check for gauge.
            // TODO: view shit outta here?
            // TODO: need to do the smooth gauge, but use the sync as override
            var heroesSync = args;
            for (var i = 0; i < heroesSync.length; i++) {
              var theHero = this.heroes[heroesSync[i][0]];
              theHero.turnGauge = heroesSync[i][1];
              updateHero(theHero);
            }
            counter += 0.5;
            break;
          case 'heroes_ready':
            var readyHeroes = args;
            for (var i = 0; i < readyHeroes.length; i++) {
              var theHero = this.heroes[readyHeroes[i]];
              theHero.statuses.ready = true;
              theHero.turnGauge = 100.00;
              updateHero(theHero);
            }
            break;
          case 'action':
            // execute action
            console.log('CLIENT action' + theEvent.content);
            //this.executeAction(theEvent.content);
            break;
          default:
            console.log('Unknown event type: ' + theEvent.type);
            break;
        }
      }
      // adds the specified players to the game
      GC.addPlayers = function(players) {
        for (var i = 0; i < arguments.length; i++) {
          var curPlayer = arguments[i];
          this.players.push(curPlayer);
          for (var j = 0; j < curPlayer.party.heroes.length; j++) {
            var curHero = curPlayer.party.heroes[j];
            this.heroes[curHero.id] = curHero;
          }
        }
      }

      GC.getPlayerByHeroId = function(heroId) {
        for(var i = 0; i < this.players.length; i++) {
          for(var j = 0; j < this.players[i].party.heroes.length; j++) {
            if (party.heroes[j] && party.heroes[j].id == heroId) {
              return this.players[i];
            }
          }
        }
      }

      /** END Game (Client) **/


      /***********************************************************************/


      /** View stuff */
      function updateHero(hero) {
        var player = gameClient.getPlayerByHeroId(hero.id);
//        console.log(hero);
        var isYou = player == YOU;
        var heroRow = $('#hero_' + hero.id);
        var heroGauge = $('#hero_' + hero.id + ' .gauge div');
        var heroHp = $('#hero_' + hero.id + ' .hp');
        // don't update dead people!
        if (hero.statuses.dead) {
          if (!heroRow.hasClass('dead')) {
            heroRow.addClass('dead');
            heroHp.text(hero.attributes.hp);
          }
          return;
        }
        // update gauge
        heroGauge.width(hero.turnGauge + '%');
        // update hp
        heroHp.text(hero.attributes.hp);
        // update readiness
        if (hero.statuses.ready && heroRow.children('td.action').is(':empty')) {
          heroRow.children('.action').html('<button class="takeAction" heroId="' + hero.id + '">Action</button>');
          heroGauge.addClass('ready');

          // TODO: this belongs somewhere else
          // enemy attacks immediately!
          if (!isYou) {
            var target = YOU.party.heroes[_.random(0, YOU.party.heroes.length-1)];
//            game.queueAction({type: 'attack', by: hero.id, target: target.id});
//            takeAction(hero);
          }
        }
      }

      // take action => reset gauge & action buttons
      function takeAction(hero) {
        var heroGauge = $('#hero_' + hero.id + ' .gauge div');
        $('#hero_' + hero.id + ' .action').html('');
        hero.statuses.ready = false;
        hero.turnGauge = 0.00;
        heroGauge.removeClass('ready');
        updateHero(hero);
      }

      // action button => target list
      $(document).on('click', '.hero .takeAction', function(event) {
        var heroId = $(this).attr('heroId');
        var targetList = '<span>';
        for (var i = 0; i < ENEMY.party.heroes.length; i++) {
          var curHero = ENEMY.party.heroes[i];
          targetList += '<button class="attack" heroId="'+ heroId +'" targetId="' + curHero.id + '">' + curHero.name + ' </button>';
        }
        targetList += '</span>';
        $(this).replaceWith(targetList);

        });
      // target list => take action
      $(document).on('click', '.hero .attack', function(event) {
        var hero = YOU.party.getHeroById($(this).attr('heroId'));
        var target = ENEMY.party.getHeroById($(this).attr('targetId'));
        game.queueAction({type: 'attack', by: hero.id, target: target.id});
        takeAction(hero);
        });
      /** END View stuff */
      

      // TODO: much of this should be 'server side'.
      var clock = new Clock(SECOND/FPS);
      var gameInstance = new GameInstance(clock);
      // *YOU
      var player = new Player(1, 'milton');
      var party = new Party(1, 4);
      party.setHero(rollPlayerHero(1, 'Jergens'));
      party.setHero(rollPlayerHero(2, 'Milton'));
      party.setHero(rollPlayerHero(3, 'Haruka'));
      player.setParty(party);
      YOU = player;

      // *OPPONENT
      var enemy = new Player(2, 'enemy');
      var enemyParty = new Party(1, 4);
      enemyParty.setHero(rollCpuHero(100, 'Teh Badguy'));
      enemyParty.setHero(rollCpuHero(200, 'Wagglerstein'));
      enemy.setParty(enemyParty);
      ENEMY = enemy;

      gameInstance.addPlayers(player, enemy);

      var gameClient = new GameClient(player.id);
      gameClient.setup(gameInstance);
      gameClient.start();

      // TODO: this should be in view thing
      for (var i = 0; i < YOU.party.heroes.length; i++) {
        var curHero = YOU.party.heroes[i];
        $("#party > tbody").append('<tr id="hero_'+ curHero.id +'" class="hero" position="'+ i +'" heroId="' + curHero.id +'"><td>' + curHero.name + '</td><td class="hp">' + curHero.attributes.hp + '</td><td class="gauge"><div></div></td><td class="action"></td></tr>');
      }
      for (var i = 0; i < ENEMY.party.heroes.length; i++) {
        var curHero = ENEMY.party.heroes[i];
        $("#enemy > tbody").append('<tr id="hero_'+ curHero.id +'" class="hero" position="'+ i +'"><td>' + curHero.name + '</td><td class="hp">' + curHero.attributes.hp + '</td><td class="gauge"><div></div></td><td class="action"></td></tr>');
      }

      // TODO: logic and state => engine
      var textX = 50;
      var textY = 50;
      var counter = 0;

      function update() { 
      }
      function draw() {
        canvas.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        canvas.fillStyle = "#000"; // Set color to black
        canvas.fillText(counter, textX, textY);
      }


    </script>
  </div>
  </body>
</html>
